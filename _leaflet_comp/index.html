<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;background:#060a14;overflow:hidden}
#map{width:100%;height:100%}
.tile-tooltip{
    background:rgba(6,10,20,.95)!important;
    color:#48cae4!important;
    border:1px solid rgba(56,120,200,.35)!important;
    border-radius:6px!important;
    padding:5px 10px!important;
    font-size:12px!important;
    font-family:'JetBrains Mono',monospace!important;
    box-shadow:0 2px 10px rgba(0,0,0,.5)!important;
    pointer-events:none!important;
    white-space:nowrap!important;
}
.tile-tooltip::before{
    border-top-color:rgba(56,120,200,.35)!important;
}
.leaflet-draw-toolbar a{background-color:#111827!important;border-color:rgba(56,120,200,.2)!important;color:#38bdf8!important}
.leaflet-draw-toolbar a:hover{background-color:#1e293b!important}
.draw-toast{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);background:#111827;border:1px solid rgba(56,189,248,.3);border-radius:12px;padding:12px 20px;color:#38bdf8;font:600 13px/1.4 'DM Sans',sans-serif;z-index:9999;box-shadow:0 4px 20px rgba(0,0,0,.5);display:none;max-width:90%;text-align:center}
.draw-toast.show{display:block;animation:toastIn .3s ease}
@keyframes toastIn{from{opacity:0;transform:translateX(-50%) translateY(10px)}to{opacity:1;transform:translateX(-50%) translateY(0)}}
.zoom-hint{position:absolute;top:10px;left:50%;transform:translateX(-50%);background:rgba(17,24,39,.92);border:1px solid rgba(251,191,36,.3);border-radius:8px;padding:6px 14px;color:#fbbf24;font:500 12px 'DM Sans',sans-serif;z-index:800;pointer-events:none;display:none}
/* FIX: Ensure Leaflet tooltip pane is above canvas */
.leaflet-tooltip-pane{z-index:650!important}
.leaflet-popup-pane{z-index:700!important}
</style>
</head>
<body>
<div id="map"></div>
<div class="draw-toast" id="drawToast"></div>
<div class="zoom-hint" id="zoomHint"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script>
(function(){
"use strict";

// ── Streamlit Component Protocol (minimal) ──────────────────────────
const Streamlit = {
    setComponentValue: function(v){
        window.parent.postMessage({isStreamlitMessage:true,type:"streamlit:setComponentValue",value:v},"*");
    },
    setFrameHeight: function(h){
        window.parent.postMessage({isStreamlitMessage:true,type:"streamlit:setFrameHeight",height:h},"*");
    }
};
window.parent.postMessage({isStreamlitMessage:true,type:"streamlit:componentReady",apiVersion:1},"*");

// ── State ────────────────────────────────────────────────────────────
let map = null;
let allTiles = [];            // compact: [{n:"01CCV", b:[minx,miny,maxx,maxy]}, ...]
let gridLayer = null;
let aoiLayer = null;
let interLayer = null;
let selLayer = null;
let nocovLayer = null;
let drawControl = null;
let drawnItems = null;
let interNames = new Set();
let selNames = new Set();
let tileSystem = "sentinel-2";
let showGrid = true;
let colorize = true;
let gridOpacity = 0.04;
let showNocov = false;
let showInter = true;
let showSel = true;
let clickSelect = true;   // FIX: default to true so clicks always register
let lastSentJSON = "";

// FIX: Use SVG renderer for grid tiles to ensure tooltips and clicks work
const gridRenderer = L.svg({padding:0.5});

const MIN_GRID_ZOOM = 5;

// ── Color functions ──────────────────────────────────────────────────
const colColors = [];
for(let i=0;i<60;i++){
    const hue=(i*137.508)%360;
    const sat=70+(i%3)*10;
    const lit=45+(i%2)*15;
    colColors.push("hsl("+hue+","+sat+"%,"+lit+"%)");
}

function s2Color(name){
    if(!name||name.length<2) return "#0077BB";
    const z=parseInt(name.substring(0,2),10);
    if(isNaN(z)||z<1||z>60) return "#0077BB";
    return colColors[z-1];
}

function lsColor(name){
    if(!name||name.length<3) return "#EE7733";
    const p=parseInt(name.substring(0,3),10);
    if(isNaN(p)) return "#EE7733";
    const hue=18+((Math.min(233,Math.max(1,p))-1)*28/233);
    return "hsl("+hue+",85%,52%)";
}

function tileColor(name){
    return tileSystem==="landsat"?lsColor(name):s2Color(name);
}

function tileStyle(name){
    const isInter = interNames.has(name);
    const isSel   = selNames.has(name);
    if(isSel) return {color:"#EE3377",weight:3,fillOpacity:0.12,dashArray:"6,4"};
    if(isInter) return {color:"#AA3377",weight:2.2,fillOpacity:0.09};
    const c = colorize ? tileColor(name) : (tileSystem==="landsat"?"#EE7733":"#0077BB");
    return {color:c,weight:1.2,fillOpacity:gridOpacity};
}

// ── Map Init ─────────────────────────────────────────────────────────
function initMap(center, zoom){
    map = L.map("map",{
        center: center,
        zoom: zoom,
        zoomControl: true,
        preferCanvas: false,
        maxZoom: 19,
        minZoom: 2
    });

    // Base layers
    const satellite = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        {attribution:"Esri",maxNativeZoom:19,maxZoom:22}
    );
    const dark = L.tileLayer(
        "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
        {attribution:"CartoDB",maxZoom:20}
    );
    const streets = L.tileLayer(
        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        {attribution:"OSM",maxZoom:19}
    );
    satellite.addTo(map);
    L.control.layers({"Satellite":satellite,"Dark":dark,"Streets":streets},{},
        {position:"topright",collapsed:true}).addTo(map);

    // Draw control
    drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);
    drawControl = new L.Control.Draw({
        position:"topleft",
        draw:{
            polyline:false, circle:false, marker:false, circlemarker:false,
            rectangle:{shapeOptions:{color:"#CCBB44",weight:2,fillOpacity:0.08}},
            polygon:{shapeOptions:{color:"#CCBB44",weight:2,fillOpacity:0.08}}
        },
        edit:{featureGroup:drawnItems,edit:true,remove:true}
    });
    map.addControl(drawControl);

    // Draw events
    map.on(L.Draw.Event.CREATED, function(e){
        drawnItems.clearLayers();
        drawnItems.addLayer(e.layer);
        sendDrawnAOI();
    });
    map.on(L.Draw.Event.EDITED, sendDrawnAOI);
    map.on(L.Draw.Event.DELETED, function(){
        drawnItems.clearLayers();
        sendDrawnAOI();
    });

    // Viewport-driven grid update
    let moveTimer = null;
    map.on("moveend zoomend", function(){
        clearTimeout(moveTimer);
        moveTimer = setTimeout(updateGridDisplay, 80);
    });
    map.on("zoomend", updateZoomHint);

    updateZoomHint();
    Streamlit.setFrameHeight(document.body.scrollHeight || 700);
}

// ── Send drawn AOI back to Python ────────────────────────────────────
function sendDrawnAOI(){
    let wkt = "";
    drawnItems.eachLayer(function(layer){
        const latlngs = layer.getLatLngs();
        if(!latlngs || !latlngs.length) return;
        const ring = latlngs[0] || latlngs;
        if(ring.length < 3) return;
        const coords = ring.map(function(ll){return ll.lng.toFixed(6)+" "+ll.lat.toFixed(6)});
        coords.push(coords[0]);
        wkt = "POLYGON(("+coords.join(",")+"))";
    });
    maybeSend({type:"aoi", wkt:wkt});
    if(wkt){
        showToast("AOI drawn — processing...");
    }
}

// ── Tile click handler ───────────────────────────────────────────────
function onTileClick(name){
    if(!name) return;
    if(!clickSelect) return;
    maybeSend({type:"tile_click", name:name});
    showToast("Tile: " + name + " (toggled)");
}

// ── Deduplicated send ────────────────────────────────────────────────
function maybeSend(data){
    const j = JSON.stringify(data);
    if(j !== lastSentJSON){
        lastSentJSON = j;
        Streamlit.setComponentValue(data);
    }
}

// ── Zoom hint ────────────────────────────────────────────────────────
function updateZoomHint(){
    const hint = document.getElementById("zoomHint");
    if(!map || !hint) return;
    const z = map.getZoom();
    if(showGrid && z < MIN_GRID_ZOOM){
        hint.textContent = "Zoom to "+MIN_GRID_ZOOM+"+ for grid (current: "+z+")";
        hint.style.display = "block";
    } else {
        hint.style.display = "none";
    }
}

// ── Toast ────────────────────────────────────────────────────────────
function showToast(msg){
    const el = document.getElementById("drawToast");
    if(!el) return;
    el.textContent = msg;
    el.classList.add("show");
    setTimeout(function(){el.classList.remove("show")}, 2500);
}

// ── Grid Display (client-side viewport filtering) ────────────────────
function updateGridDisplay(){
    if(!map) return;
    const zoom = map.getZoom();

    if(!showGrid || zoom < MIN_GRID_ZOOM || !allTiles.length){
        if(gridLayer){map.removeLayer(gridLayer); gridLayer=null;}
        return;
    }

    const bounds = map.getBounds();
    const w = bounds.getWest(), e = bounds.getEast();
    const s = bounds.getSouth(), n = bounds.getNorth();

    const visible = [];
    for(let i=0; i<allTiles.length; i++){
        const t = allTiles[i];
        const b = t.b;
        if(b[2]>=w && b[0]<=e && b[3]>=s && b[1]<=n){
            visible.push(t);
        }
    }

    const features = [];
    for(let i=0; i<visible.length; i++){
        const t = visible[i];
        const b = t.b;
        features.push({
            type:"Feature",
            properties:{name:t.n},
            geometry:{
                type:"Polygon",
                coordinates:[[
                    [b[0],b[1]], [b[2],b[1]],
                    [b[2],b[3]], [b[0],b[3]],
                    [b[0],b[1]]
                ]]
            }
        });
    }

    const geojson = {type:"FeatureCollection", features:features};

    if(gridLayer){
        map.removeLayer(gridLayer);
        gridLayer = null;
    }

    gridLayer = L.geoJSON(geojson, {
        renderer: gridRenderer,
        interactive: true,
        bubblingMouseEvents: false,
        style: function(f){ return tileStyle(f.properties.name); },
        onEachFeature: function(f, layer){
            var name = f.properties.name;
            layer.bindTooltip(name, {
                className:"tile-tooltip",
                sticky:true,
                direction:"top",
                offset:[0,-8],
                opacity:1
            });
            layer.on("click", function(e){
                if(e && e.originalEvent){ L.DomEvent.stopPropagation(e.originalEvent); }
                onTileClick(name);
            });
            layer.on("mouseover", function(){
                if(!selNames.has(name) && !interNames.has(name)){
                    layer.setStyle({weight:2.5, fillOpacity:0.12});
                }
            });
            layer.on("mouseout", function(){
                layer.setStyle(tileStyle(name));
            });
        }
    }).addTo(map);
}

// ── Refresh grid styles ──────────────────────────────────────────────
function refreshGridStyles(){
    if(!gridLayer) return;
    gridLayer.eachLayer(function(layer){
        if(layer.feature && layer.feature.properties){
            var name = layer.feature.properties.name;
            layer.setStyle(tileStyle(name));
        }
    });
}

// ── AOI layer ────────────────────────────────────────────────────────
function updateAOI(geojsonStr){
    if(aoiLayer){map.removeLayer(aoiLayer); aoiLayer=null;}
    if(!geojsonStr || geojsonStr==="null") return;
    try{
        var data = JSON.parse(geojsonStr);
        aoiLayer = L.geoJSON(data, {
            style:{color:"#CCBB44",weight:2.5,fillOpacity:0.10,dashArray:"5,5"}
        }).addTo(map);
    }catch(e){
        console.error("AOI parse error:", e);
    }
}

// ── No-coverage layer ────────────────────────────────────────────────
function updateNocov(geojsonStr){
    if(nocovLayer){map.removeLayer(nocovLayer); nocovLayer=null;}
    if(!showNocov || !geojsonStr || geojsonStr==="null") return;
    try{
        var data = JSON.parse(geojsonStr);
        nocovLayer = L.geoJSON(data, {
            style:{color:"#CC3311",weight:1.5,fillOpacity:0.04}
        }).addTo(map);
    }catch(e){
        console.error("Nocov parse error:", e);
    }
}

// ── Handle render from Streamlit ─────────────────────────────────────
let prevGridHash = null;
let prevAoiHash = null;
let prevNocovHash = null;
let prevInterHash = null;
let prevSelHash = null;

function onStreamlitRender(args){
    var opts = args.options ? JSON.parse(args.options) : {};
    showGrid    = opts.show_grid !== false;
    colorize    = opts.colorize !== false;
    gridOpacity = opts.opacity != null ? opts.opacity : 0.04;
    showNocov   = !!opts.show_nocov;
    showInter   = opts.show_inter !== false;
    showSel     = opts.show_sel !== false;
    clickSelect = opts.click_select !== false;
    tileSystem  = args.tile_system || "sentinel-2";

    var center = args.center ? JSON.parse(args.center) : [48.8566, 2.3522];
    var zoom = args.zoom || 8;

    if(!map){
        initMap(center, zoom);
    }

    if(args.fly_to){
        var ft = JSON.parse(args.fly_to);
        map.flyTo([ft[0], ft[1]], ft[2] || map.getZoom(), {duration:0.5});
    }

    var gh = args.grid_hash || "";
    if(gh !== prevGridHash && args.grid_compact){
        prevGridHash = gh;
        try{
            allTiles = JSON.parse(args.grid_compact);
        }catch(e){allTiles=[];}
        if(gridLayer){map.removeLayer(gridLayer); gridLayer=null;}
        updateGridDisplay();
    }

    var ah = args.aoi_hash || "";
    if(ah !== prevAoiHash){
        prevAoiHash = ah;
        updateAOI(args.aoi_geojson);
    }

    var nh = args.nocov_hash || "";
    if(nh !== prevNocovHash){
        prevNocovHash = nh;
        updateNocov(args.nocov_geojson);
    }

    var newInter = args.inter_names || "[]";
    var newSel   = args.sel_names   || "[]";
    var interChanged = (newInter !== prevInterHash);
    var selChanged   = (newSel   !== prevSelHash);

    if(interChanged || selChanged){
        interNames = new Set(JSON.parse(newInter));
        selNames   = new Set(JSON.parse(newSel));
        prevInterHash = newInter;
        prevSelHash   = newSel;
        refreshGridStyles();
    }

    updateZoomHint();
}

// ── Listen for Streamlit render events ───────────────────────────────
window.addEventListener("message", function(event){
    if(!event.data) return;
    if(event.data.type === "streamlit:render"){
        onStreamlitRender(event.data.args || {});
    }
});

})();
</script>
</body>
</html>